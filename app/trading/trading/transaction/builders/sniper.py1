from solbot_cache import AccountAmountCache, MintAccountCache
from solbot_common.constants import (
    ASSOCIATED_TOKEN_PROGRAM,
    PUMP_BUY_METHOD,
    PUMP_FUN_ACCOUNT,
    PUMP_FUN_PROGRAM,
    PUMP_GLOBAL_ACCOUNT,
    PUMP_SELL_METHOD,
    RENT_PROGRAM_ID,
    SOL_DECIMAL,
    SYSTEM_PROGRAM_ID,
    TOKEN_PROGRAM_ID,
    WSOL,
)
from solbot_common.IDL.pumpfun import PumpFunInterface
from solbot_common.log import logger
from solbot_common.utils.utils import get_bonding_curve_account, get_global_account
from solders.keypair import Keypair  # type: ignore
from solders.pubkey import Pubkey  # type: ignore
from solders.transaction import VersionedTransaction  # type: ignore
from spl.token.instructions import (
    CloseAccountParams,
    close_account,
    create_associated_token_account,
    get_associated_token_address,
)

from trading.exceptions import BondingCurveNotFound
from trading.swap import SwapDirection, SwapInType
from trading.tx import build_transaction
from trading.utils import has_ata, max_amount_with_slippage, min_amount_with_slippage

from .base import TransactionBuilder
from typing import Optional
from solana.rpc.websocket_api import connect
from solana.rpc.commitment import Confirmed


class SniperTransactionBuilder(TransactionBuilder):
    """狙击模式交易构建器"""

    async def monitor_new_tokens(self, keypair: Keypair, amount: float, slippage_bps: int) -> None:
        """监听新代币并自动购买"""
        ws_url = self.rpc_client._provider.endpoint_uri.replace("https", "wss")
        
        async with connect(ws_url) as websocket:
            # 订阅Pump新代币事件
            await websocket.program_subscribe(
                PUMP_FUN_PROGRAM,
                Confirmed,
                encoding="base64"
            )
            
            async for response in websocket:
                # 解析新代币事件
                if response.result and response.result.value and response.result.value.accounts:
                    for account in response.result.value.accounts:
                        if account.pubkey == PUMP_GLOBAL_ACCOUNT:
                            # 获取新代币地址
                            token_address = account.data.parsed.get("mint")
                            if token_address:
                                try:
                                    # 自动购买新代币
                                    tx = await self.build_sniper_transaction(
                                        keypair=keypair,
                                        token_address=token_address,
                                        ui_amount=amount,
                                        slippage_bps=slippage_bps
                                    )
                                    # 发送交易
                                    await self.rpc_client.send_transaction(tx)
                                    logger.info(f"成功购买新代币: {token_address}")
                                except Exception as e:
                                    logger.error(f"购买代币失败: {e}")

    async def build_sniper_transaction(
        self,
        keypair: Keypair,
        token_address: str,
        ui_amount: float,
        slippage_bps: int,
        priority_fee: float | None = None,
    ) -> VersionedTransaction:
        """构建狙击模式交易"""
        owner = keypair.pubkey()
        mint = Pubkey.from_string(token_address)
        program_id = TOKEN_PROGRAM_ID
        native_mint = WSOL

        # 获取绑定曲线账户
        pump_program = PUMP_FUN_PROGRAM
        result = await get_bonding_curve_account(self.rpc_client, mint, pump_program)
        if result is None:
            raise BondingCurveNotFound("bonding curve account not found")
        bonding_curve, associated_bonding_curve, bonding_curve_account = result

        global_account = await get_global_account(self.rpc_client, pump_program)
        if global_account is None:
            raise ValueError("global account not found")

        fee_recipient = global_account.fee_recipient

        in_ata = get_associated_token_address(owner=owner, mint=native_mint)
        out_ata = get_associated_token_address(owner=owner, mint=mint)

        # 如果ATA账户不存在，需要创建
        create_instruction = None
        if not await has_ata(self.rpc_client, owner, mint):
            create_instruction = create_associated_token_account(owner, owner, mint)

        amount_specified = int(ui_amount * SOL_DECIMAL)
        max_sol_cost = max_amount_with_slippage(amount_specified, slippage_bps)
        sol_amount_threshold = max_sol_cost
        token_amount = (
            amount_specified
            * bonding_curve_account.virtual_token_reserves
            // bonding_curve_account.virtual_sol_reserves
        )

        input_accounts = {
            "fee_recipient": fee_recipient,
            "mint": mint,
            "bonding_curve": bonding_curve,
            "associated_bonding_curve": associated_bonding_curve,
            "associated_user": out_ata,
            "user": owner,
            "global": PUMP_GLOBAL_ACCOUNT,
            "system_program": SYSTEM_PROGRAM_ID,
            "token_program": TOKEN_PROGRAM_ID,
            "rent": RENT_PROGRAM_ID,
            "event_authority": PUMP_FUN_ACCOUNT,
            "program": PUMP_FUN_PROGRAM,
        }

        instructions = []
        pumpfun = PumpFunInterface(keypair, self.rpc_client)
        pump_method = pumpfun.program.methods["buy"]
        build_swap_instruction = (
            pump_method.args([token_amount, sol_amount_threshold])
            .accounts(input_accounts)
            .instruction()
        )

        if create_instruction is not None:
            instructions.append(create_instruction)
        if amount_specified > 0:
            instructions.append(build_swap_instruction)

        return await build_transaction(
            self.rpc_client,
            keypair,
            instructions,
            priority_fee=priority_fee,
        )